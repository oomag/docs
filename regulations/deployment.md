# Регламент по доставке ПО

Данный регламент содержит общие рекомендации по доставке ПО в тестовые и
промышленные контуры работы.


## Общие положения

При разработке ПО с долгим циклом поддержки необходимо иметь правила доставки
и развертывания данного ПО на конечное оборудование для того, чтобы
минимизировать затраты на этот процесс и четко понимать, какие действия
необходимо предпринять в случае нештатных ситуаций. Процесс доставки ПО как
правило делится на два неразрывных этапа - Continuous Integration и
Continuous Delivery. В дальнейшем по тексту они будут упоминаться как CI и CD.

## Описание методик работы
### Инструменты

Для организации CI/CD рекомендуется использовать широко распространенные
инструменты. Так, для CI рекомендуется использовать:

* Jenkins
* TeamCitykk
* TravisCI
* CircleCI

Для процесса CD рекомендуется использовать известные системы провиженинга,
такие как:

* Ansible
* Puppet
* Chef
* Salt

### Методика доставки

Для доставки кода рекомендуется применять многоуровневую систему доставки. Так,
имеет смысл кроме промышленного контура (production) иметь тестовый (testing)
и стейджинг (stage) контуры. Код, который разработчик хочет выкатить на
production, после успешного прохождения тестов сначала выкатывается на stage,
на котором проходит интеграционные тесты. Если данные тесты проходятся успешно,
то код автоматически получает минорную версию и постфикс, однозначно
определяющий его в системе версий, после чего выкатывается в тестовый контур.
На тестовом контуре данный код должен пройти ручную проверку на соответствие
качеству, после чего ответственное лицо может принять решение о назначении
данному коду минорной версии и выкатки его в промышленный контур. Если такое
решение не принимается, то данному коду не присваивается версия и в
промышленный контур он попадает только как часть последующих коммитов (при
этом все равно происходит слияние данного кода с master веткой репозитория).
Пример:

1. Разработчик создал pull request из коммита abcde1. Данный коммит прошел
   автоматические тесты и CD система отправила его в stage контур.

  * если коммит не прошел интеграционные тесты на этом этапе, то возможность
    его слияния с target веткой блокируется автоматически
  * если коммит прошел интеграционные тесты, то возможность его слияния
    разрешается

2. После процесса ревью пулл реквест сливается с веткой testing.

  * из коммита автоматически собирается артефакт с уникальной версией билда,
    которая является постфиксом для текущей минорной версии ПО
  * коммит доставляется в testing контур
  * если по истечении проверки ответственное лицо решает, что данный коммит
    должен быть доставлен в промышленный контур, то это происходит **вручную**
    с явным тегированием коммита в master ветке и присвоением ему новой версии.
    После этого новая версия собирается в CI системе и доставляется через CD
    систему
  * если по истечении проверки ответственное лицо решает, что данный коммит
    **не** должен быть доставлен в промышленный контур, то происходит ручное
    слияние данного коммита с веткой master без присвоения ему новой версии.

Данный подход позволяет иметь удобный процесс тестирования с абсолютным
контролем всего кода, доставляемого в промышленный контур. При этом он не лишен
недостатков, так то: каждый коммит проверяется вручную и при наличии долгих
интеграционных тестов и/или увеличенного потока коммитов на тестирование,
процесс слияния с мастером может быть увеличен. Эту проблему можно обойти
путем качественного улучшения тестов ПО и установкой автоматической системы
гейтинга, такой как [Zuul][1]

[1]: https://zuul-ci.org/docs/zuul/
